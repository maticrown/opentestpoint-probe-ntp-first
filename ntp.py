'''
System Processes Probe
'''

import psutil
import time
import ntplib

from otestpoint.interface import Probe
from otestpoint.interface.measurementtable_pb2 import MeasurementTable
import otestpoint.toolkit.logger as Logger
from .processes_pb2 import Measurement_system_processes


class Processes(Probe):
    def initialize(self,configurationFile=None):
        '''
        Initialize the probe.
        Returns:
        The probe name list.
        '''
        self._logger.log(Logger.DEBUG_LEVEL,
                         '/time/ntp initialize'
                         ' configuration: %s' % configurationFile)

        self._measurement = Measurement_time_ntp()

        self._measurement_processes_labels = ('PID',
                                              'Command',
                                              'Affinity',
                                              'User',
                                              'System',
                                              'Runtime')

        self._measurement.ntp.labels.extend(self._measurement_ntp_labels)


        return ('time ntp',)


    def start(self):
        self._logger.log(Logger.DEBUG_LEVEL,'/time/ntp start')


    def stop(self):
        self._logger.log(Logger.DEBUG_LEVEL,'/time/ntp stop')


    def destroy(self):
        self._logger.log(Logger.DEBUG_LEVEL,'/time/ntp destroy')


    def probe(self):
        self._logger.log(Logger.DEBUG_LEVEL,'/time/ntp probe')

        self.parse_ntp_parameters()

        return (('Time ntp',
                 self._measurement.SerializeToString(),
                 self._measurement.description.name,
                 self._measurement.description.module,
                 self._measurement.description.version),)



    def parse_ntp_utilization(self):
        del self._ntp.rows[:]

        now_time_secs = time.time()

        for ntp in ntplib:
            row = self._measurement.ntp.rows.add()

            process = psutil.Process(pid)

            # PID
            value = row.values.add()
            value.type = MeasurementTable.Measurement.TYPE_UINTEGER
            value.uValue = 

            # Command
            value = row.values.add()
            value.type = MeasurementTable.Measurement.TYPE_STRING
            value.sValue = 

            # Affinity
            value = row.values.add()
            value.type = MeasurementTable.Measurement.TYPE_STRING
            value.sValue = 

            # User
            value = row.values.add()
            value.type = MeasurementTable.Measurement.TYPE_DOUBLE
            value.dValue = 

            # System
            value = row.values.add()
            value.type = MeasurementTable.Measurement.TYPE_DOUBLE
            value.dValue = 

            # Runtime
            value = row.values.add()
            value.type = MeasurementTable.Measurement.TYPE_DOUBLE
            value.dValue = 


def default_method_format(self, measurement):
    def fromMeasurement(measurement):
        if measurement.type == MeasurementTable.Measurement.TYPE_UINTEGER:
            return measurement.uValue,str(measurement.uValue)
        elif measurement.type == MeasurementTable.Measurement.TYPE_DOUBLE:
            return measurement.dValue,'%0.2f' % measurement.dValue
        else:
            return measurement.sValue,measurement.sValue


    def format_table(table):
        buf = ''

        widths = [];

        for label in table.labels:
            widths.append(len(label))

        for row in table.rows:
            for i,value in enumerate(row.values):
                widths[i] = max(widths[i],len(fromMeasurement(value)[1]))

        for i,label in enumerate(table.labels):
            buf += '|' + label.ljust(widths[i])
        buf += "|\n"

        for row in table.rows:
            for i,value in enumerate(row.values):
                val = fromMeasurement(value)[1]
                buf += '|' + val.rjust(widths[i])
            buf += "|\n"

        return buf

    buf = '[] processes\n'
    buf += format_table(measurement.processes)
    buf += '--\n'

    return buf
Â© 2020 GitHub, Inc.
Terms
Privacy
Security
Status
Help
Contact GitHub
Pricing
API
Training
Blog
About
